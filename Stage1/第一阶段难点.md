# 查询配置文件

rpm -qc 命令

c:conf

# tar -C指令打包某个目录下所有文件问题

```


举例：在root下有oldboyd/，需要你在/root路径，使用tar指令打包其中的所有文件
tar -zcvf oldboy.tar.gz -C ./oldboy * 错误
tar -zcvf oldboy.tar.gz -C ./oldboy . 正确
```

**为什么？**

Shell执行命令会进行五个阶段

1. 词法分析

   拆词，用上面的指令举例，就是将指令拆分为 tar、-zcvf 、oldboy.tar.gz、-C、./oldboy、*

2. 通配符展开

   *被当前目录下的所有文件名替换（Shell自动执行）

3. 变量替换 略

4. 命令替换、重定向等 略

5. 真正执行命令

```bash
所以在执行之前，这条命令已经变成
tar -zcvf oldboy.tar.gz -C ./oldboy /root/1.txt /root/2.txt /root/oldboy.tar.gz...
```

```bash
在最后执行指令的时候，tar接收到的参数并不是./oldboy里的文件，而是/root中的文件
```

# 不sort排序直接uniq -c与sort排序后uniq -c结果不一致问题

uniq -c是判断**相邻两行**是否为相同，如果相同则去重，不同则不去重

如果没有先排序再去重，会出现**跨行重复统计**的问题

# 非重点使用sed与egrep统计单词数量与awk统计的区别

#### 这是使用sed与egrep进行统计

```bash
sed -r 's#[-0-9:/x]+# #g' passwd |egrep '\b[a-zA-Z]+\b' -o | sort |uniq -c |sort -rnk1 | head
```

思路是：

​	先用sed将其中的所有分隔符替换为空格，再使用 egrep筛选单词并**显示匹配过程(一行输出一个单词)**，这里**也可以使用|xargs -n1**,不过这样写太长了所以不想写，再排序、去重+统计、排序、显示前10行

#### 这是使用awk进行统计

```bash
awk -F '[-0-9:/x ]+' '{for(i=1;i<=NF;i++)print $i}' passwd  | sort | uniq -c | sort -rnk1 | head

awk -F '[-0-9:/x ]+' '{for(i=1;i<=NF;i++) if($i!="") count[$i]++} END {for(word in count) if(count[word]>5) print word, count[word]}' passwd
```

思路是：

​	使用awk -F 将所有自己不想筛选出来的替换成分隔符，再用循环打印每一列（每个单词），再进行排序、去重+统计、排序、显示前10行

**个人感觉只是思路差异，没有好坏之分**

# 正则表达式相关

## 正则表达式不支持\d表示数字问题

其实是Linux使用的是**POSIX**正则，与**PCRE**正则不同，不能使用\d表示数字，要么使用[0-9]、要么使用[:digit:]表达数字

# sed后向引用问题

## 举例:我想在显卡设置中找到本机ip号

```bash
[root@oldboy-lnb ~]#ifconfig ens33 | sed -En '2s#([^ ]+)([ ]+)([^ ]+)#\3#gp'
        10.0.0.200  255.255.255.0  10.0.0.255
[root@oldboy-lnb ~]#ifconfig ens33 | sed -En '2s#([^ ]+)([ ]+)([^ ]+)#\3#1p'
        10.0.0.200  netmask 255.255.255.0  broadcast 10.0.0.255
```

g所在的位置指定的是替换第几个，如果g则**整行内**符合正则表达式的都替换

```bash
可以使用后向引用
[root@oldboy-lnb ~]#ifconfig ens33 | sed -En '2s#([^0-9]+)([0-9.]+)([^0-9]+)([0-9.]+)([^0-9]+)([0-9.]+)#\2#gp'
10.0.0.200
来筛选IP号，不过直接使用hostname -I查找更方便
```



#### 关于s命令的替换

 只能替换指定数字或整行符合正则表达式的内容，而且**不存在只替换**从第2个到第4个这样的操作

# md5sum -c命令

md5sum -c会在**当前目录下**寻找存储校验码的文件中的文件（相对路径）

所以生成校验码并存储时，请使用find指令**生成**对应文件的**绝对路径**并存储

# sed与awk实现字符串拼接

```bash
useradd test01;echo test123.com|passwd  --stdin test01
useradd test02;echo test123.com|passwd  --stdin test02
useradd test03;echo test123.com|passwd  --stdin test03

[root@oldboyedu ~]#echo {01..03}|xargs -n1|awk '{print "useradd test" $1}'
useradd test01
useradd test02
useradd test03


[root@oldboyedu ~]#echo {01..03}|xargs -n1|sed -r 's#(.*)#useradd test\1#g'
useradd test01
useradd test02
useradd test03

实现创建用户并设置密码
[root@oldboy-lnb oldboy]#echo test{01..10} | xargs -n1 | sed -E 's#(.*)#useradd \1\;echo test123.com\|passwd \-\-stdin \1#g'
useradd test01;echo test123.com|passwd --stdin test01
useradd test02;echo test123.com|passwd --stdin test02
useradd test03;echo test123.com|passwd --stdin test03
useradd test04;echo test123.com|passwd --stdin test04
useradd test05;echo test123.com|passwd --stdin test05
useradd test06;echo test123.com|passwd --stdin test06
useradd test07;echo test123.com|passwd --stdin test07
useradd test08;echo test123.com|passwd --stdin test08
useradd test09;echo test123.com|passwd --stdin test09
useradd test10;echo test123.com|passwd --stdin test10
[root@oldboy-lnb oldboy]#echo test{01..10} | xargs -n1 | awk '{print "useradd "$1";echo test123.com|passwd --stdin "$1}'
useradd test01;echo test123.com|passwd --stdin test01
useradd test02;echo test123.com|passwd --stdin test02
useradd test03;echo test123.com|passwd --stdin test03
useradd test04;echo test123.com|passwd --stdin test04
useradd test05;echo test123.com|passwd --stdin test05
useradd test06;echo test123.com|passwd --stdin test06
useradd test07;echo test123.com|passwd --stdin test07
useradd test08;echo test123.com|passwd --stdin test08
useradd test09;echo test123.com|passwd --stdin test09
useradd test10;echo test123.com|passwd --stdin test10
创建密码
pwgen指令		password generate
数字	指定生成密码的位数
-s secure	生成完全随机密码
-y symbols	密码中至少有1个特殊符号
批量生成test1-test10并设置随机密码 
echo test{01..10} | xargs -n1 | sed -E 's#(.*)#useradd \1\;echo \`pwgen -sy 8\`\| passwd \-\-stdin \1#g' | sh
```

# 隐藏权限

```bash
chatter +a file
lsatter file
a 追加
i 不可变
```

# 目录本质

目录本质上只是一个**映射表**或者**索引表**

所以在只有r权限的时候只能看到表里面记录的文件名称，查看inode号与其他详细信息需要x权限

# MBR与GPT是两种不同的分区机制

使用fdisk进行分区，默认使用MBR机制进行分区，但是可以指定ng，g参数指使用GPT机制进行分区。

parted工具进行分区，要先使用mklabel指定分区机制。

# 目录大小

```bash
du -sh	来查看单个目录的总大小
```



# lsof(list open file)和ps axuf的区别？

```bash
		lsof				ps axuf
	显示被打开的文件			显示进程
lsof -i:端口号可以显示端口号	
查看文件占用等情况			查看资源占用和高负载进程
```

# RAID级别

![image-20251124104645544](C:\Users\yellowsea\AppData\Roaming\Typora\typora-user-images\image-20251124104645544.png)

# 静态路由配置

```bash
Router>	用户模式
Router> enable -->	进入特权模式
Router#	特权模式
Router# configure terminal(完整命令)-->	进入全局配置模式
configure terminal可以简写为	conf t
Router(config)#	全局配置模式

Router(config)# int fa0/0	设置0/0接口		int:interface	fa:fastEhernet
Router(config)# ip address 10.0.0.1 255.255.255.0	(以10.0.0.0网段举例)	将网关设置为10.0.0.1

# 如果只有1个路由器连接1个局域网的情况:
Router(config)# int fa0/1	设置0/1接口
Router(config)# ip address 11.22.33.1 255.255.255.0	(以11.22.33.0网段举例)	将网关设置为11.22.33.1

# 如果连接的是另一个路由器(对方路由器的ip地址为1.1.1.2):
Router(config)# int fa0/1
# 将出网ip设置为1.1.1.1
Router(config)# ip address 1.1.1.1	
no shut
# 设置静态路由
# 我的理解是:要连接到11.22.33.0/24网段，对方路由器的ip为1.1.1.2
Router(config)# ip route 11.22.33.0	255.255.255.0 1.1.1.2	

相应的，对方的路由器也需要设置相同的配置
# 设置网关
Router(config)# int fa0/0
Router(config)# ip address 11.22.33.1 255.255.255.0
Router(config)# no shut
# 设置出网ip(对外的ip)
Router(config)# int fa0/1
Router(config)# ip address 1.1.1.2 255.255.255.0
Router(config)# no shut
# 设置静态路由	连接到10.0.0.0/24网段,对方路由器的ip为1.1.1.1
Router(config)# ip route 10.0.0.0 255.255.255.0 1.1.1.1
```

# 网络通信之ARP表

**在同一个局域网 (LAN) 内**，数据帧的传输最终是依靠 **MAC地址** 来寻址和转发的。

**IP地址** 负责**跨网络**的逻辑寻址（确定目标网络和设备），是路由的依据。

**MAC地址** 负责**局部网络**的物理寻址（确定数据在下一跳的具体物理设备），是数据帧在链路层（二层）转发的依据。

当您在主机 A 上 `ping` 同一子网内的主机 B 时，主机 A 会执行以下步骤：

1. **检查路由表：** 确定目标 IP 地址 $B_{IP}$ 是否在本地网络。
2. **检查 ARP 表/缓存：**
   - **有记录：** 如果 $B_{IP}$ 对应的 $B_{MAC}$ 地址存在于 ARP 表中，主机 A 直接使用这个 $B_{MAC}$ 封装 ICMP (ping) 报文并发送。
   - **无记录：** 如果找不到，主机 A 就会发起 **ARP 广播请求**，直到收到主机 B 的 **ARP 响应** 获得 $B_{MAC}$，并将其记录到自己的 ARP 表中。
3. **发送数据：** 只有成功获取 MAC 地址后，`ping` 命令的 ICMP 请求才能被正确封装和发送。



### 3. **关于设备更换导致的 `Ping` 不通**



**最常见、最典型的故障现象和原因。**

当一个 IP 地址（例如 $192.168.1.50$）从一台旧设备（$MAC_{old}$）迁移到另一台新设备（$MAC_{new}$）时，短期内网络中可能会出现 `ping` 不通的现象，其核心原因就是 **ARP 表老化和缓存过期的问题**：

| **阶段**       | **设备/角色**                                                | **存储的 ARP 记录**                         | **结果**        |
| -------------- | ------------------------------------------------------------ | ------------------------------------------- | --------------- |
| **设备更换前** | 主机 A 的 ARP 表                                             | $192.168.1.50 \to MAC_{old}$                | 通信正常        |
| **设备更换后** | 主机 A 尝试 Ping                                             | $192.168.1.50 \to MAC_{old}$ (Stale/旧记录) | ❌ **Ping 不通** |
| **原因分析**   | 主机 A 认为 $192.168.1.50$ 仍在 $MAC_{old}$ 上，但实际上该 MAC 地址已无效。它将 ICMP 报文发送给了错误的物理地址，导致新设备 $MAC_{new}$ 无法接收和响应。 |                                             |                 |
| **解决方案**   | **等待老化：** 等待主机 A 的 ARP 表中的旧条目老化（TTL过期）。**强制更新：** 手动在主机 A 上清除 ARP 缓存，迫使主机 A 重新发起 ARP 广播来学习 $MAC_{new}$。 |                                             |                 |

# DNS解析流程

![image-20251124214010553](C:\Users\yellowsea\AppData\Roaming\Typora\typora-user-images\image-20251124214010553.png)





# TCP协议各个字段的含义

```bash
SYN Synchronized	同步
ACK Acknowledge		确认
SEQ sequence		序列
FIN finish			结束
RST reset			重置
PSH push			推送
URG	urgent			紧急

```

```bash
TCP状态机
建立连接阶段：
LISTEN		监听状态	服务端
SYN-SENT	发送同步	客户端
SYN-RCVD	接收同步	服务端
ESTABLISHED	已建立连接	双端
连接终止阶段：
FIN-WAIT-1	终止等待1	主动关闭方
FIN-WAIT-2	终止等待2	主动关闭方
CLOSE-WAIT	关闭等待	被动关闭方
LAST-ACK	最后确认	被动关闭方
TIME-WAIT	时间等待	主动关闭方
CLOSED		关闭状态	双端
MSL		Maximum	Segment Lifetime	最长报文寿命
```

# TCP握握手握握双手

![image-20251125205552418](C:\Users\yellowsea\AppData\Roaming\Typora\typora-user-images\image-20251125205552418.png)

# TCP4次挥手

![image-20251125204203119](C:\Users\yellowsea\AppData\Roaming\Typora\typora-user-images\image-20251125204203119.png)
