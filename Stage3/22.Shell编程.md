# Shell编程

## 1. Shell规范

```tex
脚本开头指定解释器#/bin/bash 虽然可写可不写，但是规范性的话我个人偏向于要写
脚本文件名以.sh结尾
脚本文件名最好可以见名知意
脚本最好放在同一个路径
脚本写注释，最好写上作用、功能、作者
```



## 2. Shell脚本的执行

```tex
sh、bash
绝对路径、相对路径./，不过这种需要给脚本+x执行权限
. source的方式执行，其实.也相当于source
其他执行脚本的方式：
curl zabbix.linuxnc.com/test.sh | bash	# 也就是管道符交给bash执行
bash < test.sh
```

### **两种执行方式的区别**

#### sh、bash、路径


bash与**路径执行**相同，都是在子shell中执行命令，只会影响到子shell中的变量，**不会影响**父shell的变量


#### . source


在父shell中执行命令，命令会改变父shell中的变量




## 3. Shell变量

除了与编程语句相通的变量外，还有全局生效的变量与局部生效的变量

> [!NOTE]
>
> 可以使用unset 变量名 来取消变量

全局生效的变量

系统变量，写入到/etc/profile之类的变量
export: 加上以后可以让子shell也能继承，但是**仅限于当前窗口**




局部生效的变量

就是自定义的普通变量==

**关于变量名的规则**

```tex
只允许下划线、字母、数字
不能以数字开头
定义变量时等号两端不能有空格
可以使用大驼峰、小驼峰等
```

**关于变量名的拼接**

> [!TIP]
>
> 这里使用$()而不使用反引号``是因为反引号有时需要转义

例如

```bash
#字符串拼接
IP=$(hostname -I | awk '{print $1}')
HOST=$(hostname)
TIME=$(date +%F:%H:%M)

DIR=$IP\_$HOST\_$TIME	# 下划线_需要转义，否则会被当作变量名的一部分
DIR=${IP}_${HOST}_$TIME	# 或者使用{}来明确划分变量名
echo $DIR
echo "该脚本的PID是$$"
sleep 300
```



## 4. 与变量相关的文件

各种变量执行的顺序

```bash
/etc/profile
$HOME/.bash_profile
$HOME/.bash_rc
/etc/bashrc
```

## 5. 特殊变量$

> [!NOTE]
>
> 可以使用sh -x 查看脚本的执行过程

```bash
$0		# 当前脚本的名称
$n		# n为数字，举例：$1表示脚本接收的第1个参数，$2表示接收的第2个参数，以此类推
$#		# 表示脚本接收到的参数的个数
$?		# 表示上一条命令返回的结果 0为成功 非0为失败
$$		# 表示执行脚本的PID号
$!		# 表示上一个在后台运行脚本的PID号，调试脚本时使用
$*		# 表示接收所有的传参，在循环体中二者不同
$@		# 表示接收所有的传参，在循环体中二者不同
$_		# 表示脚本收到的最后一个参数
```

$*与$@的区别

```bash
set -- "I am" oldboy	# 这里是强行将$1 $2设置为I am和oldboy了
for i in $*/$@; do echo $i; done
I
am
oldboy	# 这里是bash自动将中间有空格的单词进行了拆分
for i in "$*"; do echo $i; done
I am oldboy

for i in "$@"; do echo $i; done
I am
oldboy
```

对$*与$@的理解

$*可以看作char\*，循环时可以看作字符串指针，遍历的是"I am oldboy"

$@可以看作char**，可以看作字符串数组，遍历的是{"I am","oldboy"}

> [!TIP]
>
> 永远**不要**给变量上双引号，遍历参数列表时永远只用"$@"

## 6. 变量传参

1.直接传参

```bash
echo name=$1 age=$2
```

2.先赋值，然后传参

```bash
num1=$1
num2=$2
echo $num1
echo $num2
```

3.read读入（交互式）

```bash
# 传参
echo "This script is called: " $0
read -p "Please enter your name: " name
read -p "Please enter your age: " age

read -p # 在输入前打印提示信息
read -s # 安静模式，输入字符时不再在屏幕上显示，用于输入密码

echo "Your name is $name"
echo "Your age is $age"
echo "There are $# params"
```

## 7. 变量的字串

统计字串的长度

```bash
# 统计长度
name=oldboy
echo $name | wc -L
expr length $name
echo $name | awk '{print length}'
```

统计字符串长度

```bash
# 统计字符串长度并输出长度小于3的字符串
string="I am Yellowsea I am 18"
for i in $string
do
    [ ${#i} -lt 3 ] && echo $i
done
```

输出长度小于3的字符串

> [!TIP]
>
> 除了使用${#i}，还可以使用awk

```bash
# 统计长度小于3的字符串
string="I am Yellowsea I am 18"
for i in $string
do
    [ ${#i} -lt 3 ] && echo $i
done

echo $string | xargs -n1 | awk '{if (length < 3) print $0}'

echo $string | awk '{for(i=1;i<=NF;i++) if (length($i) <3 ) print $i}'
```

## 8. 字串删除

从前往后删除

```bash
# 从前向后删除
url=www.baidu.com
echo ${url#*.}
echo ${url##*.}      # 贪婪匹配,%也支持贪婪匹配
```

从后向前删除

```bash
# 从后向前删除
echo ${url%com}

# 取df -h /dev/sda3的使用情况
disk=$(df -h | awk 'NR==6{print$(NF-1)}')
echo ${disk%\%}     # 这里删除%需要使用转义
```

字串的替换

```bash
# 子串的替换
echo ${url/w/W}     # 将第一个w替换为W
echo ${url/www/W}   # 多个替换为一个
echo ${url/w/WWW}   # 一个替换为多个
echo ${url//w/W}    # 贪婪匹配并替换
```

## 9. 数值运算

```bash
# 数值运算
expr 1 + 1     # 使用expr进行计算中间需要有空格，支持四则运算，不支持小数
expr 10 \* 10  # 这里需要对*号进行转义
expr 11 % 10
expr 1+1       # 否则只会输出字符串

echo $((10+10))      # 不支持小数，运算效率最高
echo $((11%10))      # 可以取余

echo $[11%10]         # 不支持小数，同样支持取余

let i++				# 类似i++之类的用法只能通过let
echo $i
```

变量参与运算

```bash
# 运算中也支持变量
num1=10
num2=20

expr $num1 + $num2 # 其他的运算方式也支持使用变量
```

支持小数的运算

```bash
# 支持整数与小数的运算
echo 10+20 | bc
echo 0.5*0.5 | bc       # 这个值是0.2
echo 10.12345+10.5 | bc
bc <<< 10.12345+10.5
# bc还支持小数的比较，true则返回1，false则返回0
$(bc <<< "1.5 > 0")


awk 'BEGIN{print 10/3}'     # awk也支持小数的运算
```

传参实现简单的加减乘除

```bash
# 传入3个参数，实现简单的加减乘除
echo "传输3个参数，前两个是数字，最后一个是运算符，实现简单的加减乘除"
read -p "传入第一个数字: " num1
read -p "传入第二个数字: " num2
read -p "传入运算符" operator
result=$(($num1$operator$num2))
echo "$num1$operator$num2=$result"
```

## 10. 整数比较

> [!TIP]
>
> 支持数字、变量、命令进行比较

```bash
-eq		# equal
-ne		# not equal
-gt		# greater than
-ge		# greater equal
-lt		# lesser than
-le		# lesser equal
-o		# or
-a		# and
```

**语法**

> [!WARNING]
>
> **整数！整数！整数！只支持整数！**

```bash
test 10 -eq 10
[ 10 -eq 10 ]
```

## 11. 文件比较

```bash
-f		# 文件是否存在且为普通文件
-d		# 文件是否存在且为目录
-e		# 文件是否存在
-r		# 文件是否可读
-w		# 文件是否可写
-x		# 文件是否可执行
```

```bash
[ -f /etc/hosts ]
[ -d /etc ]
[ -e /etc/passwd ]
[ -r /etc/hosts ]
[ -w /etc/hosts ]
[ -x /etc/hosts ]
```

判断文件是否存在，存在则执行

```bash
name.sh
name=gege
test.sh
[ -f /root/scripts/name.sh ] && . /root/scripts/name.sh
echo $name
```

## 12. 字符串判断

```bash
-n		# 字符串长度不为0,则成立
-z		# 字符串长度为0，则成立
```

语法

```bash
test a = a
[ a = a ]
[ a != a ]
[ -n a ]
[ -z a ]
```

案例

```bash
read -p "请输入您的姓名: " name

[ -z $name ] && echo "必须输入姓名" && exit		# 如果$name长度不为0

read -p "请输入您的年龄: " age
[ -z $age ] && echo "必须输入年龄" && exit

echo name=$name
echo age=$age 
```

name.txt

```tex
zhangsan 123456
lisi  654321
```

对name.txt取值比较

```bash
#!/bin/bash

read -p "请输入您的用户名: " name
num=$(grep -w $name /root/scripts/name.txt | wc -l)	# 
[ $num -ne 1 ] && echo "用户名输入错误，请重新输入" && exit	# 判断是否有

read -p "请输入密码: " passwd
[ $passwd != $(grep -w $name /root/scripts/name.txt | awk '{print $NF}') ] && echo "密码输入错误，请重新输入" && exit

echo "登录成功！"
```

## 13. 正则判断

语法

```bash
[[ root =~ ^r ]]
[[ root =~ t$ ]]
[[ root =~ [a-z] ]]		# 只要有任意字符可以匹配得上就成立
[[ root =~ [a-z]+ ]]

正则表达式中使用与和或使用符号，而不是-a和-o
[[ &&  || ]]
&&	# 表示与
||	# 表示或
```

```bash
[[ root1 =! ^[a-z]+$]] && echo 成立 || echo 不成立	# 字母开头字母结尾
不成立

# 通过正则匹配控制传入的参数
```

判断姓名原年龄是否合法

```bash
#!/bin/bash

while true; do

    # 输入姓名
    read -p "请输入您的姓名: " name

    # 判断是否输入姓名
    if [ -z $name ]; then
        echo "错误: 姓名不能为空！"
        continue
    fi

    # 判断是否合法
    if [[ ! $name =~ ^[a-Z]+$ ]]; then
        echo "错误: 姓名必须为连续的英文字母！"  
        continue
    fi

    break
done 

while true; do  

    # 输入年龄
    read -p "请输入您的年龄" age

    # 判断是否为空
    if [[ -z  "$age" ]]; then
        echo "错误:  输入不能为空，请重新输入。"
        continue
    fi

    # 判断是否为纯数字 (正则表达式)
    if [[ ! "$age" =~ ^[0-9]+$ ]]; then
        echo "错误：年龄必须是纯数字（'$age' 不是合法数字）。"
        continue
    fi

    # 判断数字范围
    if [[ "$age" -lt 0 || "$age" -ge 100 ]]; then
        echo "错误：年龄必须在 0 到 99 之间。"
        continue
    fi

    break
done

echo "您的姓名是: $name"
echo "您的年龄是: $age"

echo "你好，$name！"
```

## 14. if判断

语法

单分支情况

```bash
if [ 条件表达式 ]
then 
	命令
fi

if [ 条件表达式 ]; then
	命令
fi
```

多分支情况

```bash
if [ 条件表达式1 ]; then
	命令1
elif [ 命令表达式2 ]; then
	命令2
...
else
	命令n
fi
```

菜单

```bash
#!/bin/bash

while true; do
    echo -e "\e[34m\t\t\t1.炒菜类\e[0m"
    echo -e "\e[34m\t\t\t2.凉菜类\e[0m"
    echo -e "\e[34m\t\t\t3.烧烤类\e[0m"
    echo -e "\e[34m\t\t\t4.主食类\e[0m"
    echo -e "\e[34m\t\t\t0.退出\e[0m"

    read -p "点菜请输入编号: [1|2|3|4...]" num

    case "$num" in 
        1)
            while true; do
                echo -e "\e[31m\t\t\t1.炒土豆丝\e[0m"
                echo -e "\e[31m\t\t\t2.炒胡萝卜\e[0m"
                echo -e "\e[31m\t\t\t0.退出\e[0m"

                read -p "想吃什么？请输入编号喔！" num1
                case "$num1" in
                1)
                    echo "服务员给你上了一盘地地道道的酸辣土豆丝"
                ;;
                2)
                    echo "服务员给你上了一盘地地道道的炒胡萝卜"
                ;;
                0)
                    echo "返回上级菜单"
                    break
                ;;
                *)
                    echo "菜单上似乎没有这一道菜呢？"
                ;;
                esac
            done
        ;;
        2)
            while true; do
                echo -e "\e[31m\t\t\t1.夫妻肺片\e[0m"
                echo -e "\e[31m\t\t\t2.凉拌鸡丝\e[0m"
                echo -e "\e[31m\t\t\t0.退出\e[0m"

                read -p "想吃什么？请输入编号喔！" num1
                case "$num1" in
                1)
                    echo "服务员给你上了一盘夫妻肺片"
                ;;
                2)
                    echo "服务员给你上了一盘凉拌鸡丝"
                ;;
                0)
                    echo "返回上级菜单"
                    break
                ;;
                *)
                    echo "菜单上似乎没有这一道菜呢？"
                ;;
                esac
            done
        ;;

        3)
            while true; do
                echo -e "\e[31m\t\t\t1.烤羊肉串\e[0m"
                echo -e "\e[31m\t\t\t2.烤鸡心\e[0m"
                echo -e "\e[31m\t\t\t0.退出\e[0m"

                read -p "想吃什么？请输入编号喔！" num1
                case "$num1" in
                1)
                    echo "服务员给你上了一份烤羊肉串"
                ;;
                2)
                    echo "服务员给你上了一份烤鸡心"
                ;;
                0)
                    echo "返回上级菜单"
                    break
                ;;
                *)
                    echo "菜单上似乎没有这一道菜呢？"
                ;;
                esac
            done
        ;;

        4) 
            while true; do
                echo -e "\e[31m\t\t\t1.白米饭\e[0m"
                echo -e "\e[31m\t\t\t2.面条\e[0m"
                echo -e "\e[31m\t\t\t0.退出\e[0m"

                read -p "想吃什么？请输入编号喔！" num1
                case "$num1" in
                1)
                    echo "服务员给你上了一碗热腾腾的白米饭"
                ;;
                2)
                    echo "服务员给你上了一碗热乎乎的面条"
                ;;
                0)
                    echo "返回上级菜单"
                    break
                ;;
                *)
                    echo "菜单上似乎没有这一道菜呢？"
                ;;
                esac
            done
        ;;
        0)
            echo "谢谢光临，欢迎下次再来！"
            break
        ;;
        *)
            echo "菜单上似乎没有这一道菜呢？"
        ;;
        esac
done
```

## 15. while循环

```bash
while[ 条件表达式 ] do
	命令
done

while read line;do		# read 读行，以行进行分隔(for循环以空格进行分隔)
	
done < text.txt
```

读行案例

```bash
#!/bin/bash

while read line
do
    echo $line
done < /etc/hosts
```



## 16. case

```bash
case 值 in
	值1)
		命令
	;;
	值2)
		命令
	;;
	...
	*)
		什么都不输入默认执行这一块
	;;
esac
```

## 17. 函数

```bash
# 里面的函数不需要考虑类型
# 函数的声明
函数名(){		# 没有参数的函数

}
function fun(){		# 有括号

}
function fun {			# 没有括号，但是必须有空格

}
# 调用时直接使用函数名即可


# 函数可以接收参数，但是参数直接跟在函数后面
funWithParam(){
    echo "第一个参数为 $1 ！"
    echo "第二个参数为 $2 ！"
    echo "第十个参数为 ${10} ！"
    echo "第十一个参数为 ${11} ！"
    echo "参数总共有 $# 个！"
    echo "输出所有的参数 $@ ！"
    return
}
funWithParam 1 2 3 4 5 6 7 8 9 10 11 12 13

local		# local关键字定义 局部变量
```

## 18. for循环

```bash
for i in 要放的参数 ;do

done

# 支持循环整数、字符串、序列、变量、命令
# for循环按照空格来进行分隔
```

## 19. 数组

```bash
# 普通数组的定义
declare -a array
# 索引定义
array[0]=第0个元素
array[1]=第一个元素

# 直接定义
array=(A B C D)

# 混合定义
array=([2]=awk sed [5]=zabbix find)

# 数组支持命令
array=($(ls))

# 遍历数组
for i in ${array[@]}; do
	echo ${array[$i]}
done


# 关联数组
# 定义关联数组
declare -A array
array[index1]=
array[index2]=

echo ${array[0]} # 输出第0个元素
echo ${!array[*]} # 输出数组的下标

# 查看所有普通数组
declare -a

# 查看所有关联数组
declare -A
```





双色球案例

```bash
# 双色球
# 声明变量
red_balls=()
count=1

redball_gen(){
    while true;do

        # 生成随机数
        num=$((RANDOM % 33 + 1))

        # 检查是否重复
        is_repeated=false
        for i in "${red_balls[@]}";do
            if [ "$i" -eq "$num" ]; then
                is_repeated=true
                break
            fi
        done

        # 不重复则放入数组
        if [ "$is_repeated" = false ]; then
            # sleep 1
            echo "生成第"${count}"个红球，编号为: ${num}"
            red_balls+=($num)
            ((count++))
        fi

        if  [ "$count" -eq 7 ]; then
            break
        fi

    done
}

# 生成红球
redball_gen
# 生成蓝球
blue_ball=$((RANDOM % 16 + 1 ))
echo "生成蓝球，编号为: $blue_ball"

# 排序输出红球（为了美观）
sorted_red=$(echo "${red_balls[@]}" | tr ' ' '\n' | sort -n | tr '\n' ' ')

echo "红球：$sorted_red | 蓝球：$blue_ball"

# 双色球2
redball_gen=$(seq 1 33 | shuf -n 6 | sort -n | tr '\n' ' ')
blueball_gen=$(seq 1 16 | shuf -n 1)

echo "红球:$redball_gen"
echo "蓝球:$blueball_gen"

seq 1 33 	# 生成1-33的序列
shuf -n		# 打乱并取前n个
```

后台并发案例

```bash
# 探测网段是否有主机在线
for i in $(seq 254);do
    { 
        ip="10.0.0.$i"
        ping -c1 -W1 "$ip" &> /dev/null
        if [ $? -eq 0 ];then
            echo "$ip 在线"
        fi
    } &
done
wait
echo "探测完毕"
```

### 1. 为什么你的代码会报错？

报错的主要原因有两个：

- **空格要求**：在 Bash 中，左花括号 `{` 后面必须有一个空格，右花括号 `}` 前面通常也需要一个空格或分号。
- **终止符**：花括号内的最后一个命令必须以分号 `;` 结尾（或者换行）。

### 2. 为什么加了 `&` 就能并发运行？

这其实涉及到操作系统层面的**进程管理**。

通常情况下，脚本是**顺序执行**的：Shell 启动一个程序，然后“阻塞”（等待）在那里，直到这个程序运行结束，Shell 才会继续执行下一行。

当你加上 `&` 符号时，发生了一件奇妙的事情：

1. **派生子进程 (Fork)**：Shell 会为 `{...}` 里的代码块创建一个“子 Shell”进程。
2. **后台运行**：Shell 不再等待这个子进程结束，而是直接把这个任务丢给操作系统内核去调度，然后**立即回到循环开头**，处理下一个 `$i`。
3. **多路齐下**：由于循环跑得非常快，在短短几毫秒内，Shell 就启动了 254 个几乎同时运行的 `ping` 进程。

### 1. 什么是 `<<<` ？ (Here-string)

你之前学过 `>`（覆盖重定向）和 `>>`（追加重定向），它们通常用于将内容写入**文件**。

而 `<<<` 被称为 **Here-string**。它的作用是：**把一个字符串直接“喂”给某个命令的标准输入**。

- **对比 `echo` 管道：** `echo "100 * 0.8" | bc` （原理：先启动 echo 打印字符串，再通过管道传给 bc）
- **对比 `<<<`：** `bc <<< "100 * 0.8"` （原理：直接告诉 bc，你的输入内容就是后面这个字符串。这种写法更高效，因为它少启动了一个 `echo` 进程。）

```bash
# 使用 read 直接把一行拆分成变量，非常方便
            read -r vName vPass vBalance < <(grep -w "^$name" vip.txt)
```

**`< <(...)` (进程替换)**：这是个高级货，它把命令的输出当成一个临时文件。配合 `read` 使用，可以一次性把“名称、密码、余额”分别存入三个变量，比你分三次用 `awk` 提要快得多。

**`^` 和 `\$`**：在 `sed` 中使用这两个符号就像给搜索加了“边界”，防止它在这一行中间乱动。



点菜程序

```bash
#!/bin/bash

# 大饭店

# 结账时的价格
totalPrise=0
# 是否登录
login=false
# 存储用户信息的文本
DB_File="vip.txt"
# 欢迎语
hello(){
    echo -e "\e[34m\t\t\t欢迎光临小店\e[0m"
    return 0
}
# 提供服务
servers(){
    echo -e "\e[34m\t\t\t1.我要点单！\e[0m"
    echo -e "\e[34m\t\t\t2.会员服务\e[0m"
    echo -e "\e[34m\t\t\t0.退出\e[0m"
    echo -e "\e[34m\t\t\t会员点单全场8折喔？\e[0m"
    read -p "需要什么服务，请输入编号喔！" numServer
    return 0
}
# 点菜主菜单
mainMenu(){
    echo -e "\e[34m\t\t\t1.炒菜类\e[0m"
    echo -e "\e[34m\t\t\t2.凉菜类\e[0m"
    echo -e "\e[34m\t\t\t3.烧烤类\e[0m"
    echo -e "\e[34m\t\t\t4.主食类\e[0m"
    echo -e "\e[34m\t\t\t0.结账&返回主菜单\e[0m"
    read -p "想要吃点什么，请输入编号喔？" numMain
    return 0
}
# 炒菜类
friedMenu(){
    echo -e "\e[34m\t\t\t1.炒青菜\e[0m"
    echo -e "\e[34m\t\t\t2.炒土豆丝\e[0m"
    echo -e "\e[34m\t\t\t3.地三鲜\e[0m"
    echo -e "\e[34m\t\t\t4.番茄炒蛋\e[0m"
    echo -e "\e[34m\t\t\t0.退出\e[0m"
    read -p "想要吃点什么，请输入编号喔？" numFried
    return 0
}
# 冷菜类
coldMenu(){
    echo -e "\e[34m\t\t\t1.凉拌海带丝\e[0m"
    echo -e "\e[34m\t\t\t2.皮蛋拌豆腐\e[0m"
    echo -e "\e[34m\t\t\t3.蒜泥白肉\e[0m"
    echo -e "\e[34m\t\t\t4.白灼虾\e[0m"
    echo -e "\e[34m\t\t\t0.退出\e[0m"
    read -p "想要吃点什么，请输入编号喔？" numCold
    return 0
}
# 烧烤类
bbqMenu(){
    echo -e "\e[34m\t\t\t1.奥尔良烤鸡\e[0m"
    echo -e "\e[34m\t\t\t2.烤茄子\e[0m"
    echo -e "\e[34m\t\t\t3.烤羊排\e[0m"
    echo -e "\e[34m\t\t\t4.蜜汁翅中\e[0m"
    echo -e "\e[34m\t\t\t0.退出\e[0m"
    read -p "想要吃点什么，请输入编号喔？" numBbq
    return 0
}
# 主食类
stapleMenu(){
    echo -e "\e[34m\t\t\t1.米饭\e[0m"
    echo -e "\e[34m\t\t\t2.拌面\e[0m"
    echo -e "\e[34m\t\t\t3.煎饺\e[0m"
    echo -e "\e[34m\t\t\t4.汤面\e[0m"
    echo -e "\e[34m\t\t\t0.退出\e[0m"
    read -p "想要吃点什么，请输入编号喔？" numStaple
    return 0
}
# 点单服务
orderServer(){
    while true;do
        # 主菜单
        mainMenu
        case $numMain in
            1)
                while true;do
                    # 炒菜
                    friedMenu
                    case $numFried in
                    1)
                        echo "服务员上了一盘炒青菜"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    2)
                        echo "服务员上了一盘炒土豆丝"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    3)  
                        echo "服务员上了一盘地三鲜"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    4)
                        echo "服务员上了一盘番茄炒蛋"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    0)
                        echo "返回到上级菜单"
                        break
                    ;;
                    *)
                        echo "菜单中似乎没有这个选项呢？"
                    ;;
                    esac
                done
            ;;
            2)
                while true;do
                    # 冷菜
                    coldMenu
                    case $numCold in
                    1)
                        echo "服务员上了一盘凉拌海带丝"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    2)
                        echo "服务员上了一盘皮蛋拌豆腐"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    3)  
                        echo "服务员上了一盘蒜泥白肉"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    4)
                        echo "服务员上了一盘白灼虾"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    0)
                        echo "返回到上级菜单"
                        break
                    ;;
                    *)
                        echo "菜单中似乎没有这个选项呢？"
                    ;;
                    esac
                done
            ;;
            3)
                while true;do
                    # 烧烤
                    bbqMenu
                    case $numBbq in
                    1)
                        echo "服务员上了一盘奥尔良烤鸡"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    2)
                        echo "服务员上了一盘烤茄子"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    3)  
                        echo "服务员上了一盘烤羊排"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    4)
                        echo "服务员上了一盘蜜汁翅中"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    0)
                        echo "返回到上级菜单"
                        break
                    ;;
                    *)
                        echo "菜单中似乎没有这个选项呢？"
                    ;;
                    esac
                done
            ;;
            4)
                while true;do
                    # 主食
                    stapleMenu
                    case $numStaple in
                    1)
                        echo "服务员上了一盘米饭"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    2)
                        echo "服务员上了一盘拌面"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    3)  
                        echo "服务员上了一盘煎饺"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    4)
                        echo "服务员上了一盘汤面"
                        totalPrise=$(($totalPrise+10))
                    ;;
                    0)
                        echo "返回到上级菜单"
                        break
                    ;;
                    *)
                        echo "菜单中似乎没有这个选项呢？"
                    ;;
                    esac
                done
            ;;
            # 点单
            0)
                settleAccounts
                break
            ;;
            *)
                echo "菜单中似乎没有这个选项呢？"
            ;;
        esac
    done
    return 0
}
# 会员服务菜单
vip(){
    while true;do
        echo -e "\e[34m\t\t\t1.登录\e[0m"
        echo -e "\e[34m\t\t\t2.注册\e[0m"
        echo -e "\e[34m\t\t\t0.退出\e[0m"
        read -p "需要什么服务，请输入编号喔？" numVip
        case $numVip in
            1)
                vipLogin
            ;;
            2)
                vipRegister
            ;;
            0)
                echo "返回到上级菜单"
                break
            ;;
            *)
                echo "菜单中似乎没有这个选项呢？"
            ;;
        esac
    done
    return 0
}
# 登录
vipLogin(){
    local name passwd
    read -p "请输入用户名: " name
    grep -w $name $DB_File &> /dev/null
    if [ $? -eq 0 ];then
        read -s -p "请输入密码：" passwd
        passwdVip=$(grep -w $name $DB_File | awk '{print $2}')
        if [ $passwdVip = $passwd ];then
            echo "登录成功，欢迎"$name"光临本店！"
            login=true
            # 登录成功进入会员服务
            vipServer
            # 从会员服务出来则退出函数
            login=false
            return 0
        else
            echo "密码错误，请重新输入"
        fi
    else
        echo "用户名不存在"
    fi
    
    return 0
}
# 注册
vipRegister(){
    local name passwd
    while true;do
        read -p "请输入用户名: " name
        grep -w $name $DB_File &> /dev/null
            if [ $? -eq 0 ];then
                echo "用户名已经存在，请重新输入"
                break
            else
                read -s -p "请输入密码: " passwd
                # 写入到文件
                echo "$name $passwd 500" >> $DB_File
                echo "注册成功，新客户送500元喔！"
                # 退出函数
                return 0
            fi
    done
    return 0
}
# 会员服务（登录进入）
vipServer(){
    while true;do
        echo -e "\e[34m\t\t\t1.会员点单\e[0m"
        echo -e "\e[34m\t\t\t2.查看余额\e[0m"
        echo -e "\e[34m\t\t\t3.充值服务\e[0m"
        echo -e "\e[34m\t\t\t0.退出\e[0m"
        read -p "尊敬的会员 $name 需要什么服务，请输入编号喔？" numVipServer
        case $numVipServer in
            1)
                orderServer
            ;;
            2)
                balanceQuery
            ;;
            3)
                topUpServer
            ;;
            0)
                break
            ;;
            *)
                echo "菜单中似乎没有这个选项呢？"
            ;;
        esac
    done
    return 0
}
# 查看余额
balanceQuery(){
    echo "正在查询余额……" && sleep 1
    balance=$(grep $name $DB_File | awk '{print $3}')
    echo "您的余额还剩: ${balance} 元"
    return 0
}
# 充值服务
topUpServer(){
    while true; do
        read -p "您需要充入多少呢？" chargeNum
        # 判断数字是否合法，正则判断纯整数或者2位小数，后者判断是否大于0
        if [[ "$chargeNum" =~ ^([0-9]+|[0-9+][.]?[0-9]{1,2})$ ]] && [[ $(bc <<< "$chargeNum > 0") -eq 1 ]]; then
            balance=$(grep -w $name $DB_File | awk '{print $3}')
            balanceAfter=$(bc <<< "$balance+$chargeNum")
            oldLine=$(grep -w "^$name" $DB_File)
            newLine="$name $passwd $balanceAfter"
            grep -w $name $DB_File | sed -i "s#^$oldLine\$#$newLine#" $DB_File &>/dev/null
            echo "充值成功，您的余额还剩 ${balanceAfter} 元"
            return 0
        else
            echo "输入的数值非法！请重新输入正数，且最多保留2位小数！"
        fi
    done
    return 0
}
# 结账
settleAccounts(){
    # 局部变量，防止折扣重复计算
    local finalBill
    # 会员登录的情况
    if [ "$login" = true ];then
        # 计算价格
        finalBill=$(printf "%.2f" $(bc <<< "$totalPrise * 0.8"))
        # 余额
        balance=$(grep -w $name $DB_File | awk '{print $3}')
        # 结算后的余额
        balanceAfter=$(printf "%.2f" $(bc <<< "$balance - $finalBill"))
        if [ $(bc <<< "$balanceAfter < 0") -eq 1 ]; then
            debt=$(bc <<< "$finalBill - $balance")
            echo "啊欧，余额不足了，吃不起饭了，客官请这边充值喔！"
            echo "还差 $(printf "%.2f" $debt) 元"
            # 查询余额
            balanceQuery
            # 充值服务
            topUpServer
            # 继续结账
            settleAccounts
            return 0
        fi
        oldLine=$(grep -w "^$name" $DB_File)
        newLine="$name $passwd $balanceAfter"
        # 覆盖写入余额
        sed -i "s#^$oldLine\$#$newLine#" $DB_File
        echo -e "尊敬的会员${name}，您好\n本次 8 折共优惠，消费${finalBill}元\n您的余额剩余$(printf "%.2f" $balanceAfter)}\n谢谢惠顾，欢迎下次再来"
    else
        echo -e "尊敬的客人您好，总共消费 $totalPrise 元\n谢谢惠顾，欢迎下次再来"
    fi
    return 0
}
# 主函数
main(){
    # 欢迎光临
    hello
    while true;do
        # 显示服务
        servers
        case $numServer in
        # 直接点单
        1)
            orderServer
        ;;
        # 会员服务
        2)
            vip
        ;;
        # 退出
        0)
            echo "谢谢惠顾，欢迎下次再来！"
            break
        ;;
        *)
            echo "菜单中似乎没有这个选项呢？"
        ;;
        esac
    done
}
main
```

